To cryptanalyze CMEA using know plaintext attack, we spilt the it in two phases. 
1.	Phase one:  To determine correct value of T (0)
2.	Phase two:  Backtracking and Meet-in-the-Middle

Phase one - Finding T (0):According to key scheduling scheme, the value of T (0) has to be in cave table. Even though, the cave table has 256 values, the distinct values count to 164. We guess a value called ‘t0’ from these possible 164 values as T (0). By analyzing the known plaintext and ciphertext, we validate this guess.When a T (0) value is guessed, we construct a 256 x 256 matrix of possible values for entries in T-box (16 x 16). Each row number corresponds to entry in T-box and each column number is possible value for these entries. We fill this matrix with 1s for possible values and 0s for rejected values. If we have any row with all 0s, the guessed value for T (0) is incorrect and we move on to next guess.Hence, in order to discard incorrect guesses, we have to mark 0s in the initial matrix. We do that by guessing a T-box entry i.e. ‘guess’ for (P[0] + T (0)) ^ 1. This guessed value should hold true for equations derived in next few lines.The CMEA encryption has 3 parts, of which first and third part is non-linear and second part is linear. We are denoting intermediate results of first part as p’ and second part as p’’ for each plaintext block.1.	p0' = p0 + t02.	p1’ = p1 + T(p0' ^ 1)3.	p2' = p2 + T((p0' + p1 + T(p0' ^ 1)) ^ 2)4.	p0’’ = p0' ^ (p2' | 1)5.	c0 = p0'' - t06.	c1 = p1' - T(p0'' ^ 1)7.	c2 = p2' - T((p0'' + p1') ^ 2)First equation for c0 is derived as below: 	c0 = p0’’ – t0 ___using 5.	c0 = (p0' ^ (p2' | 1)) – t0 ___using 4.	c0 + t0 = p0’ ^ (p2’ | 1)	c0 + t0 = (p0 + t0) ^ (p2' | 1) ___using 1.	c0 + t0 = (p0 + t0) ^ ((p2 + T((p0' + p1 + T(p0' ^ 1)) ^ 2)) | 1) ___using 3.	(p0 + t0) ^ (c0 + t0) = (p2 + T((p0' + p1 + T(p0' ^ 1)) ^ 2)) | 1	As the right-hand side as OR, left side can have 2 valid values ending with 0 or 1.	(p0 + t0) ^ (c0 + t0) = p2 + T((p0' + p1 + T(p0' ^ 1)) ^ 2)  AND	((p0 + t0) ^ (c0 + t0)) ^ 1 = p2 + T((p0' + p1 + T(p0' ^ 1)) ^ 2)	(ia)	((p0 + t0) ^ (c0 + t0)) – p2= T((p0' + p1 + T(p0' ^ 1)) ^ 2)  AND(ib)	(((p0 + t0) ^ (c0 + t0)) ^ 1) – p2 = T((p0' + p1 + T(p0' ^ 1)) ^ 2)We can write (ia) and (ib) equations in the form T(key) = value Hence,	Common key = (p0' + p1 + guess) ^ 2	Value 1 = ((p0 + t0) ^ (c0 + t0)) – p2	Value 2 = (((p0 + t0) ^ (c0 + t0)) ^ 1) – p2Second equation for c0 and c1 is derived as below:	c0 = p0'' - t0 ___using 51.	p0’’ = c0 + t0	c1 = p1' - T(p0'' ^ 1) ___using 7	c1 = p1’ – T((c0 + t0) ^ 1) ___using 8	T((c0 + t0)^1) = p1' - c1(ii)	T((c0 + t0)^1) = p1 + T(p0’ ^ 1) - c1 ___using 2This is equation (ii).Key = (c0 + t0)^1Value = p1 + guess - c1Third equation for c0 and c2 is derived as below:	c2 = p2' - T((p0'' + p1') ^ 2) ___using 7	T((p0'' + p1') ^ 2) = p2' - c2	T((c0 + t0 + p1’) ^ 2) = p2' - c2 ___using 82.	T((c0 + t0 + p1 + T(p0' ^ 1)) ^ 2) = p2' - c2 ___using 2p2' = p2 + T((p0' + p1 + T(p0' ^ 1)) ^ 2) ___using 3p2’ = p2 + ((p0 + t0) ^ (c0 + t0)) – p2 ANDp2’ = p2 + (((p0 + t0) ^ (c0 + t0)) ^ 2) – p2 ___using IA and IBp2’ = (p0 + t0) ^ (c0 + t0)   ANDp2’ = ((p0 + t0) ^ (c0 + t0)) ^ 2Putting these values in 9 we get equation (iiia) and (iiib)(iiia) 	T((c0 + t0 + p1 + T(p0' ^ 1)) ^ 2) = ((p0 + t0) ^ (c0 + t0)) – c2 AND(iiib)	T((c0 + t0 + p1 + T(p0' ^ 1)) ^ 2) = (((p0 + t0) ^ (c0 + t0)) ^ 2) – c2This is equation (iii)Key = (c0 + t0 + p1 + T(p0' ^ 1)) ^ 2Value 1 = ((p0 + t0) ^ (c0 + t0)) – c2Value 2 = (((p0 + t0) ^ (c0 + t0)) ^ 2) – c2Phase 2 Backtracking and Meet-in-the-Middle: 1.	Finding the pair of values for K6 and K7:Once we have the correct value of t0, we find possible values for pair of K6 and K7. We use last key scheduling equation T(x) = C [((v + x) ^ K6) + K7] + x to find the valid pairs of K6 and K7.  For each possible value of K6, K7, v (cave table entry) and x, we verify if x and T (x) is valid or not. This phase yields two pairs of K6 and K7.2.	Finding Unique T-Box entries: We search through 256 x 256 matrix, to get 4 rows with only one 1.  We denote these numbers as a, b, c, and d.3.	Construction of search table M:We calculate a = Q(a)  K2 = (C[(a  K0) + K1] + a)  K2  and similarly, b’, c’ and d’. We create table M as values as (K0, K1, K2, a’) and key as (a’ – d’, b’ – d’, c’ – d’).  This table can have 224 rows. 4.	Searching through table M: We calculate a’’ such that, it satisfies following equations:R(a) = C[a] + aS(a) = C[(R(a) ^ K4) + K5] + aT(a) = C[(S(a) ^ K6) + K7] + aSimilarly, b’’, c’’ and d’’.The correct key, should hold (a d, b d, c d) = (a d, b d, c d) .  Hence, we search (a d, b d, c d) in table M and correct match gives us the key as K0, K1, K2, K3, K4, K5, K6, K7 where K3 is a’’ – a’. We need to verify this key by encrypting known plaintext and matching it with corresponding ciphertext and vice versa. Successful verification yields valid keys. We found, first correct key after 221 attempts. This is a significant effort reduction as compared to 264 attempts with exhaustive key search. EffortBrute force18446744073709600000.002 ^ 64KPA-10020971522 ^ 21
